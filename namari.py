# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Namari
                                 A QGIS plugin
 This plugin allows you to detect anomalous features in spatial data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-02-19
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Rein van 't Veer
        email                : rein@vantveer.me
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path
from typing import List

from qgis.PyQt.QtCore import QCoreApplication, Qt, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QPushButton
from qgis.core import QgsMapLayerProxyModel, QgsVectorLayer
from qgis.gui import QgisInterface
from sklearn.feature_extraction import DictVectorizer

# Import the code for the DockWidget
from .messaging.dependencies import report_missing_dependency
from .namari_dockwidget import NamariDockWidget
from .resources import qInitResources

# Initialize Qt resources from file resources.py
qInitResources()


class Namari:
    def __init__(self, iface: QgisInterface) -> None:
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        """

        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # Declare instance attributes
        self.actions: List[QAction] = []
        self.menu = self.tr(u'&Namari anomaly detector')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Namari')
        self.toolbar.setObjectName(u'Namari')

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message: str) -> str:
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QStringQgisInterface

        :returns: Translated version of message.
        :rtype: str
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Namari', message)

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/namari/icon.png'
        text = self.tr(u'Namari anomaly detector')
        parent = self.iface.mainWindow()
        icon = QIcon(icon_path)

        action = QAction(icon, text, parent)
        action.triggered.connect(self.run)
        action.setEnabled(True)
        action.setStatusTip("Enables the Namari anomaly detector")
        action.setWhatsThis("Namari anomaly detector")

        self.toolbar.addAction(action)
        self.iface.addPluginToVectorMenu(self.menu, action)
        self.actions.append(action)

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&Namari anomaly detector'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def run(self) -> None:
        """Run method that loads and starts the plugin"""
        # First, try to load the machine learning dependency
        try:
            # import sklearn
            pass
        except ImportError:
            report_missing_dependency()
            return

        if not self.pluginIsActive:
            self.pluginIsActive = True

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget is None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = NamariDockWidget()

            assert self.dockwidget is not None

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

            # Set the layer type filter - unfortunately this is broken in the Qt designer for QGIS 3.16
            self.dockwidget.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.VectorLayer)

            # Bind an event handler invoked when the layer changes
            self.dockwidget.mMapLayerComboBox.layerChanged.connect(self.layerChanged)

            # Bind event handler for clicking the "build model" button
            self.dockwidget.pushButtonBuildModel.clicked.connect(self.buildModel)

            self.layerChanged()

    def layerChanged(self) -> None:
        assert self.dockwidget is not None  # To please the type checker
        layer: QgsVectorLayer = self.dockwidget.mMapLayerComboBox.currentLayer()
        build_button: QPushButton = self.dockwidget.pushButtonBuildModel

        if layer is not None:
            feature_counter = layer.countSymbolFeatures()

            # When the features have already been counted, the feature counter will be None
            # See https://qgis.org/pyqgis/master/core/QgsVectorLayer.html#qgis.core.QgsVectorLayer.countSymbolFeatures
            if feature_counter is not None:
                feature_counter.waitForFinished()

            build_button.setText(f'Build model ({layer.featureCount()} features)')
            build_button.setEnabled(True)

    def buildModel(self) -> None:
        print("Building model")
        assert self.dockwidget is not None    # To please the type checker
        layer: QgsVectorLayer = self.dockwidget.mMapLayerComboBox.currentLayer()
        features = layer.getFeatures()
        field_names = [f.name() for f in layer.fields()]
        vectorizer = DictVectorizer()

        print(field_names)

        feat_dicts = self.features_to_dicts(features, field_names)
        print(feat_dicts[0])

        inputs = vectorizer.fit_transform(feat_dicts[:100])

        print(f'inputs shape: {inputs.shape}')

    def features_to_dicts(self, features, field_names):
        feat_dicts = []

        for f in features:
            if f.isValid():
                if QVariant in [type(d) for d in f]:
                    continue
                feat_dict = {field: f.attribute(field) for field in field_names}
                feat_dicts.append(feat_dict)

        return feat_dicts
